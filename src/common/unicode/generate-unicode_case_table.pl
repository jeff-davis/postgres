#!/usr/bin/perl
#
# Generate Unicode character case mappings. Does not include tailoring
# or locale-specific mappings.
#
# Input: UnicodeData.txt SpecialCasing.txt
# Output: unicode_case_table.h
#
# Copyright (c) 2000-2023, PostgreSQL Global Development Group

use strict;
use warnings;
use Getopt::Long;

use FindBin;
use lib "$FindBin::RealBin/../../tools/";

my $output_path = '.';

GetOptions('outdir:s' => \$output_path);

my $output_table_file = "$output_path/unicode_case_table.h";

# The maximum number of codepoints that can result from case mapping
# of a single character. See Unicode section 5.18 "Case Mappings".
my $MAX_CASE_EXPANSION = 3;

my $FH;

my %simple = ();

open($FH, '<', "$output_path/UnicodeData.txt")
  or die "Could not open $output_path/UnicodeData.txt: $!.";
while (my $line = <$FH>)
{
	my @elts = split(';', $line);
	my $code = hex($elts[0]);
	my $simple_uppercase = hex($elts[12] =~ s/^\s+|\s+$//rg);
	my $simple_lowercase = hex($elts[13] =~ s/^\s+|\s+$//rg);
	my $simple_titlecase = hex($elts[14] =~ s/^\s+|\s+$//rg);

	die "codepoint $code out of range" if $code > 0x10FFFF;
	die "Simple_Lowercase $code out of range" if $simple_lowercase > 0x10FFFF;
	die "Simple_Titlecase $code out of range" if $simple_titlecase > 0x10FFFF;
	die "Simple_Uppercase $code out of range" if $simple_uppercase > 0x10FFFF;

	if ($simple_lowercase || $simple_titlecase || $simple_uppercase)
	{
		$simple{$code} = {Simple_Lowercase => $simple_lowercase,
						  Simple_Titlecase => $simple_titlecase,
						  Simple_Uppercase => $simple_uppercase};
	}
}
close $FH;

# Map for special casing rules that aren't represented in the simple
# mapping. Include only unconditional mappings; not those sensitive to
# context or locale.
#
# See https://www.unicode.org/reports/tr44/#SpecialCasing.txt, or the
# SpecialCasing.txt file itself for details.
my %special = ();
open($FH, '<', "$output_path/SpecialCasing.txt")
  or die "Could not open $output_path/SpecialCasing.txt: $!.";
while (my $line = <$FH>)
{
	# Stop as soon as we get to conditional mappings (unconditional
	# mappings occur first in the file).
	last if $line =~ /\# Conditional Mappings/;

	# ignore irrelevant lines (comments, extra newlines, etc.)
	next unless $line =~ /^[0-9A-F]+;[0-9A-F\s]+;[0-9A-F\s]+;[0-9A-F\s]+;/;

	my @elts = split /;/, $line;
	my $code = hex($elts[0]);

	# Codepoint may map to multiple characters when converting
	# case. Split each mapping on whitespace and extract the
	# hexadecimal into an array of codepoints.
	my @lower = map { hex $_ } (grep /[09A-F]+/, (split /\s+/, $elts[1]));
	my @title = map { hex $_ } (grep /[09A-F]+/, (split /\s+/, $elts[2]));
	my @upper = map { hex $_ } (grep /[09A-F]+/, (split /\s+/, $elts[3]));

	# none should map to more than 3 codepoints
	die "lowercase expansion for 0x$elts[0] exceeds maximum: '$elts[1]'"
	  if (scalar @lower) > $MAX_CASE_EXPANSION;
	die "titlecase expansion for 0x$elts[0] exceeds maximum: '$elts[2]'"
	  if (scalar @title) > $MAX_CASE_EXPANSION;
	die "uppercase expansion for 0x$elts[0] exceeds maximum: '$elts[3]'"
	  if (scalar @upper) > $MAX_CASE_EXPANSION;

	# pad arrays to a fixed length of 3
	while (scalar @upper < $MAX_CASE_EXPANSION) { push @upper, 0x000000 };
	while (scalar @lower < $MAX_CASE_EXPANSION) { push @lower, 0x000000 };
	while (scalar @title < $MAX_CASE_EXPANSION) { push @title, 0x000000 };

	# Characters with special mappings may not have simple mappings;
	# ensure that an entry exists.
	$simple{$code} ||= {Simple_Lowercase => 0x00,
						Simple_Titlecase => 0x00,
						Simple_Uppercase => 0x00};

	$special{$code} = {Uppercase => \@upper, Lowercase => \@lower, Titlecase => \@title};
}
close $FH;

# assign sequential array indexes to the special mappings
my $special_idx = 0;
foreach my $code (sort { $a <=> $b } (keys %special))
{
	$special{$code}{Index} = $special_idx++;
}

# Start writing out the output files
open my $OT, '>', $output_table_file
  or die "Could not open output file $output_table_file: $!\n";

my $num_special = scalar (keys %special);
my $num_simple = scalar (keys %simple);

print $OT <<"HEADER";
/*-------------------------------------------------------------------------
 *
 * unicode_case_table.h
 *	  Case mapping and information table.
 *
 * Portions Copyright (c) 1996-2023, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * src/include/common/unicode_case_table.h
 *
 *-------------------------------------------------------------------------
 */

/*
 * File auto-generated by src/common/unicode/generate-unicode_case_table.pl,
 * do not edit. There is deliberately not an #ifndef PG_UNICODE_CASE_TABLE_H
 * here.
 */

#include "mb/pg_wchar.h"

typedef struct
{
	pg_wchar	lowercase[3];
	pg_wchar	titlecase[3];
	pg_wchar	uppercase[3];
}			pg_special_case_map;

typedef struct
{
	pg_wchar	codepoint;		/* Unicode codepoint */
	pg_wchar	simple_lowercase;
	pg_wchar	simple_titlecase;
	pg_wchar	simple_uppercase;
	const		pg_special_case_map *special_case;
}			pg_simple_case_map;

/*
 * Special case mappings that aren't representable in the simple map.
 * Entries are referenced from simple_case_map.
 */
static const pg_special_case_map special_case_map[$num_special] =
{
HEADER

my $firsttime = 1;
foreach my $code (sort { $a <=> $b } (keys %special))
{
	printf $OT ",\n" unless $firsttime;
	$firsttime = 0;

	die if scalar @{$special{$code}{Lowercase}} != $MAX_CASE_EXPANSION;
	die if scalar @{$special{$code}{Titlecase}} != $MAX_CASE_EXPANSION;
	die if scalar @{$special{$code}{Uppercase}} != $MAX_CASE_EXPANSION;
	my $lower = join ", ", (map { sprintf "0x%06x", $_ } @{$special{$code}{Lowercase}});
	my $title = join ", ", (map { sprintf "0x%06x", $_ } @{$special{$code}{Titlecase}});
	my $upper = join ", ", (map { sprintf "0x%06x", $_ } @{$special{$code}{Uppercase}});
	printf $OT "\t{ /* 0x%06x */ {%s}, {%s}, {%s}}", $code, $lower, $title, $upper;
}

print $OT <<"HEADER";

};

/* simple one-to-one case mapping table */
static const pg_simple_case_map simple_case_map[$num_simple] =
{
HEADER

$firsttime = 1;
foreach my $code (sort { $a <=> $b } (keys %simple))
{
	printf $OT ",\n" unless $firsttime;
	$firsttime = 0;

	my $map = $simple{$code};
	my $special_case = "NULL";
	if (exists $special{$code})
	{
		$special_case = sprintf "&special_case_map[%d]", $special{$code}{Index};
	}
	printf $OT "\t{0x%06x, 0x%06x, 0x%06x, 0x%06x, %s}",
		$code, $map->{Simple_Lowercase}, $map->{Simple_Titlecase}, $map->{Simple_Uppercase},
		$special_case;
}
print $OT "\n};\n";
